---
phase: 13-rbac-foundation
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/routes/admin/templates/+page.server.ts
  - src/routes/admin/templates/[id]/+page.server.ts
  - src/routes/auth/signup/+page.server.ts
autonomous: true

must_haves:
  truths:
    - "Non-admin user accessing /admin/templates receives 403 Forbidden"
    - "First signup becomes admin; subsequent signups become users"
    - "User A cannot access User B's projects or BOMs"
  artifacts:
    - path: "src/routes/admin/templates/+page.server.ts"
      provides: "Admin-only template list"
      contains: "requireAdmin"
    - path: "src/routes/admin/templates/[id]/+page.server.ts"
      provides: "Admin-only template edit"
      contains: "requireAdmin"
    - path: "src/routes/auth/signup/+page.server.ts"
      provides: "First-admin logic"
      contains: "role:"
  key_links:
    - from: "src/routes/admin/templates/+page.server.ts"
      to: "src/lib/server/auth.ts"
      via: "requireAdmin import and call"
      pattern: "import.*requireAdmin.*from.*auth"
    - from: "src/routes/auth/signup/+page.server.ts"
      to: "users table"
      via: "count query for first-admin check"
      pattern: "count|findFirst"
---

<objective>
Retrofit existing admin routes with role checks and implement first-admin logic.

Purpose: Close the security vulnerability where any authenticated user can access admin routes. Implement RBAC-06 so the first registered user becomes admin automatically.
Output: Protected admin routes, first-admin assignment on signup, verified data isolation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-rbac-foundation/13-01-SUMMARY.md

@src/lib/server/auth.ts
@src/routes/admin/templates/+page.server.ts
@src/routes/admin/templates/[id]/+page.server.ts
@src/routes/auth/signup/+page.server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Retrofit /admin/templates routes with requireAdmin()</name>
  <files>src/routes/admin/templates/+page.server.ts, src/routes/admin/templates/[id]/+page.server.ts</files>
  <action>
**Critical security fix:** Replace auth-only checks with admin role checks.

**Step 1: Update src/routes/admin/templates/+page.server.ts**

Replace the existing auth check pattern with requireAdmin():

```typescript
import { requireAdmin } from '$lib/server/auth';

export const load: PageServerLoad = async (event) => {
  requireAdmin(event);  // Throws 403 if not admin

  const allTemplates = await db.query.templates.findMany({
    orderBy: [asc(templates.name)]
  });

  return { templates: allTemplates };
};

export const actions: Actions = {
  create: async (event) => {
    requireAdmin(event);  // MUST check in actions too - load doesn't protect actions

    const data = await event.request.formData();
    // ... rest of existing create logic unchanged
  }
};
```

Key changes:
- Import requireAdmin from '$lib/server/auth'
- Replace `if (!locals.user)` with `requireAdmin(event)`
- Change function signature from `({ locals })` to `(event)` to pass full event
- Access form data via `event.request.formData()` instead of destructured `request`

**Step 2: Update src/routes/admin/templates/[id]/+page.server.ts**

Same pattern - add requireAdmin() to load and ALL actions:

```typescript
import { requireAdmin } from '$lib/server/auth';

export const load: PageServerLoad = async (event) => {
  requireAdmin(event);

  const template = await db.query.templates.findFirst({
    where: eq(templates.id, event.params.id)
  });
  // ... rest unchanged
};

export const actions: Actions = {
  update: async (event) => {
    requireAdmin(event);
    const data = await event.request.formData();
    // ... rest of update logic
    // Use event.params.id instead of destructured params
  },

  delete: async (event) => {
    requireAdmin(event);
    await db.delete(templates).where(eq(templates.id, event.params.id));
    throw redirect(302, '/admin/templates');
  }
};
```

**Why actions need separate checks:**
SvelteKit form actions can be POST'd directly without going through load(). An attacker could POST to /?/create or /?/delete bypassing the load guard. Every action must independently verify authorization.
  </action>
  <verify>
Run `npm run check` - TypeScript compilation succeeds.
Run `npm run dev` and:
1. Log in as a regular user (if you have one)
2. Navigate to /admin/templates - should see 403 error
3. If no regular user exists, this will be fully testable after signup changes in Task 2
  </verify>
  <done>
Admin template routes protected by requireAdmin(). Both load() and actions check role.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add first-admin logic to signup</name>
  <files>src/routes/auth/signup/+page.server.ts</files>
  <action>
Implement RBAC-06: First registered user becomes admin; subsequent users become regular users.

Modify the signup action in src/routes/auth/signup/+page.server.ts:

```typescript
import { sql } from 'drizzle-orm';

export const actions: Actions = {
  default: async ({ request, cookies }) => {
    // ... existing validation unchanged ...

    // Check if email already exists (unchanged)
    const existing = await db.query.users.findFirst({
      where: eq(users.email, email)
    });
    if (existing) {
      return fail(400, {
        error: 'An account with this email already exists',
        email
      });
    }

    // NEW: Determine role - first user becomes admin
    const userCount = await db.select({ count: sql<number>`count(*)` })
      .from(users)
      .then(result => result[0].count);

    const role = userCount === 0 ? 'admin' : 'user';

    // Create user with role
    const id = crypto.randomUUID();
    const passwordHash = await hashPassword(password);

    await db.insert(users).values({
      id,
      email,
      passwordHash,
      role,  // NEW: include role
      createdAt: new Date()
    });

    // Create session and redirect (unchanged)
    await createSession(id, cookies);
    throw redirect(302, '/');
  }
};
```

Add `sql` import at top:
```typescript
import { eq, sql } from 'drizzle-orm';
```

**Logic explanation:**
- Count all users BEFORE inserting the new one
- If count is 0, this is the first user -> assign 'admin' role
- Otherwise, assign 'user' role (the default)

**Race condition note:** In high-traffic production, two simultaneous signups could both see count=0. For a woodworking hobby app, this is acceptable. For enterprise, you'd use a database transaction with SELECT FOR UPDATE or a separate admin-seeding mechanism.
  </action>
  <verify>
Run `npm run check` - TypeScript compilation succeeds.
To fully test:
1. If you have existing test users, delete them from the database (optional)
2. Start fresh: `npm run db:push` with empty database
3. Sign up first user - should have role='admin'
4. Sign up second user - should have role='user'
5. Check via Drizzle Studio: `npm run db:studio`
  </verify>
  <done>
First signup gets admin role. Subsequent signups get user role. RBAC-06 implemented.
  </done>
</task>

<task type="auto">
  <name>Task 3: Audit and document data isolation</name>
  <files>none (audit only)</files>
  <action>
Verify RBAC-05: Users can only see their own projects, BOMs, and cut lists.

**Audit the existing ownership checks:**

The codebase already implements data isolation through userId filtering. Verify these patterns exist:

1. **Project list (src/routes/+page.server.ts, src/routes/projects/+page.server.ts):**
   - Should have: `where: eq(projects.userId, locals.user.id)`

2. **Project detail (src/routes/projects/[id]/+page.server.ts):**
   - Should have: `where: and(eq(projects.id, params.id), eq(projects.userId, locals.user.id))`

3. **BOM access (src/routes/api/bom/[id]/+server.ts):**
   - Should verify: `bom.project.userId !== locals.user.id` returns 403

4. **BOM items (src/routes/api/bom/[id]/items/[itemId]/+server.ts):**
   - Should verify: `item.bom.project.userId !== locals.user.id` returns 403

5. **Project actions (update, delete):**
   - Should include userId in WHERE clause

**Document findings:**

After auditing, add a comment block to src/lib/server/auth.ts documenting the data isolation pattern:

```typescript
/**
 * DATA ISOLATION PATTERN
 *
 * All user data (projects, BOMs, items) uses userId ownership:
 * - Queries filter by userId: eq(table.userId, locals.user.id)
 * - Relations verify ownership: record.project.userId !== locals.user.id
 *
 * This is enforced at the route level, not middleware level,
 * because each route knows its specific ownership chain.
 *
 * Ownership chains:
 * - projects.userId -> direct
 * - boms.projectId -> project.userId -> indirect
 * - bomItems.bomId -> bom.projectId -> project.userId -> indirect
 *
 * Future: cutLists will follow same pattern via projectId.
 */
```

This documents the existing pattern for future maintainers without modifying working code.
  </action>
  <verify>
Grep the codebase for ownership patterns:
```bash
grep -r "userId.*locals.user.id\|project.userId" src/routes/
```
All data access routes should show ownership filtering.
  </verify>
  <done>
Data isolation verified. Pattern documented in auth.ts. RBAC-05 confirmed via existing implementation.
  </done>
</task>

</tasks>

<verification>
1. `npm run check` passes with no TypeScript errors
2. /admin/templates returns 403 for non-admin users
3. Admin user can still access /admin/templates normally
4. First signup creates user with role='admin'
5. Second signup creates user with role='user'
6. Existing ownership checks prevent cross-user data access
</verification>

<success_criteria>
- [ ] requireAdmin() called in /admin/templates load function
- [ ] requireAdmin() called in /admin/templates create action
- [ ] requireAdmin() called in /admin/templates/[id] load function
- [ ] requireAdmin() called in /admin/templates/[id] update action
- [ ] requireAdmin() called in /admin/templates/[id] delete action
- [ ] Signup assigns 'admin' role when user count is 0
- [ ] Signup assigns 'user' role when user count > 0
- [ ] Data isolation pattern documented in auth.ts
- [ ] npm run check passes
</success_criteria>

<output>
After completion, create `.planning/phases/13-rbac-foundation/13-02-SUMMARY.md`
</output>
