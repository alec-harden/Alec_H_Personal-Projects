---
phase: 18-cut-optimizer-foundation
plan: 03
type: execute
wave: 2
depends_on: ["18-01", "18-02"]
files_modified:
  - src/lib/server/cutOptimizer.ts
  - src/lib/components/cutlist/OptimizationResults.svelte
  - src/routes/cutlist/+page.svelte
  - src/routes/api/cutlist/optimize/+server.ts
autonomous: true

must_haves:
  truths:
    - "User can run optimization algorithm"
    - "Results display waste percentage"
    - "Results display which cuts come from which stock"
  artifacts:
    - path: "src/lib/server/cutOptimizer.ts"
      provides: "Placeholder optimization algorithms (1D and 2D)"
      exports: ["optimizeCuts1D", "optimizeCuts2D"]
    - path: "src/lib/components/cutlist/OptimizationResults.svelte"
      provides: "Results display with waste metrics"
      min_lines: 100
    - path: "src/routes/api/cutlist/optimize/+server.ts"
      provides: "API endpoint for optimization"
      exports: ["POST"]
  key_links:
    - from: "src/routes/cutlist/+page.svelte"
      to: "/api/cutlist/optimize"
      via: "fetch call"
      pattern: "fetch.*api/cutlist/optimize"
    - from: "src/routes/api/cutlist/optimize/+server.ts"
      to: "src/lib/server/cutOptimizer.ts"
      via: "algorithm import"
      pattern: "import.*optimizeCuts"
---

<objective>
Implement placeholder optimization algorithms and wire up the results display.

Purpose: Enable users to run optimization and see meaningful results. The algorithms are placeholders (simple greedy) that will be replaced with proper FFD/guillotine algorithms in Phases 19 and 20. This phase validates the data flow and results display.

Output: Working "Optimize" button that produces results showing waste percentage and cut-to-stock assignments.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-cut-optimizer-foundation/18-RESEARCH.md
@.planning/phases/18-cut-optimizer-foundation/18-01-SUMMARY.md
@.planning/phases/18-cut-optimizer-foundation/18-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create placeholder optimization algorithms</name>
  <files>src/lib/server/cutOptimizer.ts</files>
  <action>
Create placeholder optimization algorithms following the research patterns:

**Types for optimization results:**
```typescript
export interface CutAssignment {
  cutId: string;
  cutLabel: string;
  length: number;
  width: number | null;
}

export interface StockPlan {
  stockId: string;
  stockLabel: string;
  stockLength: number;
  stockWidth: number | null;
  cuts: CutAssignment[];
  wasteLength: number;      // linear inches wasted
  wasteArea: number | null; // square inches wasted (sheet mode)
}

export interface OptimizationResult {
  success: boolean;
  error?: string;
  plans: StockPlan[];
  summary: {
    totalCuts: number;
    totalStockUsed: number;
    totalWaste: number;       // linear inches or square inches
    wastePercentage: number;  // 0-100
    unplacedCuts: string[];   // cut IDs that couldn't fit
  };
}
```

**optimizeCuts1D(cuts, stock, kerf):**
- Simple greedy first-fit-decreasing algorithm
- Expand cuts by quantity (each qty=2 becomes 2 separate cuts)
- Sort cuts descending by length
- For each stock piece (expanded by quantity):
  - Try to fit cuts, accounting for kerf between cuts
  - Kerf formula: usedLength = sum(cutLengths) + (numCutsOnStock - 1) * kerf
  - Track remaining length as waste
- Return OptimizationResult with plans and summary

**optimizeCuts2D(cuts, stock, kerf):**
- Very simple placeholder (proper guillotine comes in Phase 20)
- For now: treat as 1D optimization on length only
- Calculate waste as area instead of length
- Add TODO comment: "Replace with guillotine algorithm in Phase 20"

**Validation:**
- Check that largest cut fits in largest stock (including kerf)
- Return error if any cut is too large
- Return error if cuts array or stock array is empty
  </action>
  <verify>
1. Write quick test: call optimizeCuts1D with sample data, check result structure
2. Verify kerf is accounted for (cuts + kerf should exceed available if tight)
3. Run `npm run check` - no TypeScript errors
  </verify>
  <done>
- optimizeCuts1D implements greedy FFD placeholder
- optimizeCuts2D returns placeholder results
- Both return OptimizationResult with waste calculations
- Validation catches invalid inputs
  </done>
</task>

<task type="auto">
  <name>Task 2: Create API endpoint and results display</name>
  <files>
    src/routes/api/cutlist/optimize/+server.ts
    src/lib/components/cutlist/OptimizationResults.svelte
  </files>
  <action>
**src/routes/api/cutlist/optimize/+server.ts:**
- POST endpoint that accepts JSON body:
  ```typescript
  {
    mode: 'linear' | 'sheet',
    cuts: Cut[],
    stock: Stock[],
    kerf: number
  }
  ```
- Validate required fields present
- Call optimizeCuts1D or optimizeCuts2D based on mode
- Return JSON OptimizationResult
- No authentication required (optimizer works anonymously)

**src/lib/components/cutlist/OptimizationResults.svelte:**
- Props: `result: OptimizationResult`, `mode: CutListMode`
- Summary section at top:
  - Waste percentage with color coding (green <10%, yellow <25%, red >=25%)
  - Total cuts placed / total cuts
  - Total stock pieces used
  - Visual waste bar (horizontal bar showing waste %)
- Plans section:
  - Card for each stock piece used
  - Stock dimensions shown in header
  - List of cuts assigned to that stock
  - Remaining waste shown (with visual indicator)
- Unplaced cuts warning (if any):
  - Red alert box listing cuts that couldn't fit
- Empty state if result.plans is empty

Styling:
- Use sanded-surface class for plan cards
- Color-coded waste (green/yellow/red based on percentage)
- Waste bar visualization using Tailwind width classes
- Match project aesthetic with amber accents
  </action>
  <verify>
1. POST to /api/cutlist/optimize with sample data - returns JSON
2. OptimizationResults component renders with mock result data
3. Waste percentage color coding works
4. Run `npm run check` - no TypeScript errors
  </verify>
  <done>
- API endpoint accepts cuts/stock/kerf, returns OptimizationResult
- OptimizationResults displays summary with waste percentage
- Each stock piece shows its assigned cuts
- Visual waste indicator renders
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire up optimization flow in main page</name>
  <files>src/routes/cutlist/+page.svelte</files>
  <action>
Integrate all components and wire up the optimization flow:

**State management:**
- `mode = $state<CutListMode>('linear')`
- `cuts = $state<Cut[]>([createCut('linear')])`
- `stock = $state<Stock[]>([createStock('linear')])`
- `kerf = $state<number>(0.125)`
- `result = $state<OptimizationResult | null>(null)`
- `isOptimizing = $state<boolean>(false)`
- `error = $state<string | null>(null)`

**Mode change handler:**
- When mode changes, reset cuts and stock arrays to match new mode
- Or preserve data but update width fields (null for linear, 0 for sheet)

**Layout structure:**
1. Page header (already exists from Plan 01)
2. ModeSelector (already exists from Plan 01)
3. Two-column layout on desktop:
   - Left: CutInputForm
   - Right: StockInputForm
4. KerfConfig (full width, below inputs)
5. "Optimize Cuts" button (primary, centered)
6. OptimizationResults (shown when result !== null)

**Optimize button handler:**
```typescript
async function handleOptimize() {
  isOptimizing = true;
  error = null;
  result = null;

  try {
    const response = await fetch('/api/cutlist/optimize', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ mode, cuts, stock, kerf })
    });

    if (!response.ok) {
      const data = await response.json();
      throw new Error(data.error || 'Optimization failed');
    }

    result = await response.json();
  } catch (e) {
    error = e instanceof Error ? e.message : 'An error occurred';
  } finally {
    isOptimizing = false;
  }
}
```

**Validation before optimize:**
- Disable button if cuts.length === 0 or stock.length === 0
- Show validation message if inputs invalid

**Loading state:**
- Show spinner/loading indicator while isOptimizing
- Disable button during optimization
  </action>
  <verify>
1. Navigate to /cutlist
2. Add cuts (e.g., 24", 36", 48" lengths)
3. Add stock (e.g., 96" board qty 2)
4. Click "Optimize Cuts"
5. See results with waste percentage and cut assignments
6. Try with invalid data - see error message
7. Run `npm run check` - no TypeScript errors
  </verify>
  <done>
- /cutlist page shows all input components
- "Optimize Cuts" button triggers API call
- Results display below with waste metrics
- Loading and error states handled
- Mode switching works and resets inputs appropriately
  </done>
</task>

</tasks>

<verification>
1. Algorithm: optimizeCuts1D produces valid plans with waste calculation
2. API: POST /api/cutlist/optimize returns OptimizationResult JSON
3. UI: Results display shows waste % and cut-to-stock mapping
4. Integration: Full flow from inputs -> optimize -> results works
5. Edge cases: Empty inputs, oversized cuts handled gracefully
</verification>

<success_criteria>
- Placeholder algorithms calculate and return optimization results
- API endpoint accepts inputs and returns structured results
- Results display shows waste percentage (color-coded)
- Results display shows which cuts come from which stock
- Full optimize flow works end-to-end
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/18-cut-optimizer-foundation/18-03-SUMMARY.md`
</output>
