---
phase: 19-linear-optimizer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/server/cutOptimizer.ts
autonomous: true

must_haves:
  truths:
    - "FFD algorithm sorts cuts descending by length before placement"
    - "FFD algorithm tries existing bins before opening new stock"
    - "Stock pieces are tried in order (longest first for efficiency)"
    - "Total linear feet calculation shows used vs available"
    - "Kerf is correctly accounted for between cuts (N-1 kerfs for N cuts)"
  artifacts:
    - path: "src/lib/server/cutOptimizer.ts"
      provides: "Enhanced optimizeCuts1D function with proper FFD algorithm"
      exports: ["optimizeCuts1D", "OptimizationResult"]
      contains: "expandedCuts.sort"
  key_links:
    - from: "src/routes/cutlist/+page.svelte"
      to: "/api/cutlist/optimize"
      via: "fetch POST with mode='linear'"
      pattern: "handleOptimize"
    - from: "/api/cutlist/optimize"
      to: "src/lib/server/cutOptimizer.ts"
      via: "optimizeCuts1D(cuts, stock, kerf)"
      pattern: "optimizeCuts1D"
---

<objective>
Enhance the placeholder 1D optimization algorithm with a proper First Fit Decreasing (FFD) implementation.

Purpose: The Phase 18 placeholder uses a basic greedy algorithm. FFD is a well-established bin packing heuristic that produces near-optimal results by sorting items descending before placement. This improves waste reduction for real woodworking scenarios.

Output: Enhanced `optimizeCuts1D()` function with verified FFD behavior and total linear feet summary.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-linear-optimizer/19-RESEARCH.md

@src/lib/server/cutOptimizer.ts
@src/lib/types/cutlist.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance FFD Algorithm with Stock Sorting</name>
  <files>src/lib/server/cutOptimizer.ts</files>
  <action>
Enhance the `optimizeCuts1D()` function with a proper First Fit Decreasing algorithm:

1. **Verify cut sorting (already exists):** `expandedCuts.sort((a, b) => b.length - a.length)` - confirm this is present and correct

2. **Add stock sorting:** Sort `expandedStock` descending by length BEFORE the placement loop. This ensures longest stock pieces are tried first, maximizing cuts per piece:
   ```typescript
   expandedStock.sort((a, b) => b.length - a.length);
   ```

3. **Verify kerf formula:** The existing formula `(plan.cuts.length - 1) * kerf` is correct (N-1 kerfs between N cuts). Keep this.

4. **Fix potential kerf bug in placement check:** Current code has:
   ```typescript
   const kerfLoss = plan.cuts.length > 0 ? plan.cuts.length * kerf : 0;
   ```
   This should be `(plan.cuts.length) * kerf` because we're calculating space BEFORE adding the new cut. When a bin has N cuts and we're adding one more, we need N kerf gaps (one for each existing cut plus one before the new cut). Actually review this carefully - the placement check adds `kerf` separately via `requiredLength = cut.length + (plan.cuts.length > 0 ? kerf : 0)`.

5. **Add total linear feet to summary:** Update the `OptimizationResult.summary` interface and calculation:
   - Add `totalLinearFeetUsed: number` - sum of all stock piece lengths actually used
   - Add `totalLinearFeetAvailable: number` - sum of all expanded stock lengths (what user has)

   Calculate after plans are built:
   ```typescript
   const totalLinearFeetUsed = plans.reduce((sum, plan) => sum + plan.stockLength, 0);
   const totalLinearFeetAvailable = expandedStock.reduce((sum, s) => sum + s.length, 0);
   ```

   Convert inches to feet for display: divide by 12.

6. **Keep existing validation and error handling** - the current max cut vs max stock check is correct.

Key principle: FFD = First Fit Decreasing. "Decreasing" means sorted descending. "First Fit" means take the first bin that fits (break out of loop on first match).
  </action>
  <verify>
Run the dev server and test optimization with these scenarios:

1. **Basic FFD test:**
   - Cuts: 24", 18", 12", 6" (qty 1 each)
   - Stock: 48" (qty 2)
   - Expected: 2 stock pieces used, cuts sorted as 24, 18, 12, 6 before placement

2. **Multiple stock lengths:**
   - Cuts: 70", 40", 30" (qty 1 each)
   - Stock: 96" (qty 1), 72" (qty 1)
   - Expected: 96" gets 70", 72" gets 40"+30" (or similar efficient packing)

3. **Kerf handling:**
   - Cuts: 23.5" (qty 2)
   - Stock: 48" (qty 1)
   - Kerf: 0.125"
   - Expected: Both cuts fit (23.5 + 0.125 + 23.5 = 47.125" < 48")

Verify console shows no TypeScript errors.
  </verify>
  <done>
- `optimizeCuts1D()` sorts cuts descending by length (FFD "Decreasing")
- `optimizeCuts1D()` sorts stock descending by length (try longest first)
- Kerf calculation uses correct (N-1) formula for waste calculation
- Summary includes `totalLinearFeetUsed` and `totalLinearFeetAvailable` (in feet, not inches)
- Existing tests/scenarios continue to work
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Summary Interface and Display</name>
  <files>src/lib/server/cutOptimizer.ts</files>
  <action>
Update the OptimizationResult summary interface to include linear feet metrics:

1. **Extend summary type:**
   ```typescript
   summary: {
     totalCuts: number;
     totalStockUsed: number;
     totalWaste: number;
     wastePercentage: number;
     unplacedCuts: string[];
     // NEW for Phase 19:
     totalLinearFeetUsed: number;    // feet (not inches)
     totalLinearFeetAvailable: number; // feet (not inches)
   };
   ```

2. **Calculate in optimizeCuts1D:**
   After `totalStockMaterial` calculation, add:
   ```typescript
   // Linear feet summary (convert from inches)
   const totalLinearFeetUsed = totalStockMaterial / 12;
   const totalLinearFeetAvailable = expandedStock.reduce((sum, s) => sum + s.length, 0) / 12;
   ```

3. **Update return statement** to include the new fields.

4. **Update optimizeCuts2D** to return 0 for linear feet fields (they don't apply to sheet mode):
   ```typescript
   totalLinearFeetUsed: 0,
   totalLinearFeetAvailable: 0,
   ```

5. **Update error returns** in both functions to include the new fields with value 0.

Note: The display of these values in the UI happens in Plan 02 (OptimizationResults.svelte enhancement).
  </action>
  <verify>
1. TypeScript compilation succeeds: `npm run check`
2. Test optimization returns new fields:
   - Cuts: 24" (qty 4)
   - Stock: 96" (qty 2)
   - Expected: `totalLinearFeetUsed: 8` (96" = 8'), `totalLinearFeetAvailable: 16` (192" = 16')

3. Both `optimizeCuts1D` and `optimizeCuts2D` return objects with matching structure (no type errors).
  </verify>
  <done>
- OptimizationResult.summary interface has `totalLinearFeetUsed` and `totalLinearFeetAvailable`
- Values are in feet (divided by 12), not inches
- Both 1D and 2D functions return consistent structure
- `npm run check` passes with no type errors
  </done>
</task>

</tasks>

<verification>
Run full type check and manual testing:

```bash
npm run check
npm run dev
```

Test the /cutlist page:
1. Select Linear mode
2. Add cuts with various lengths
3. Add multiple stock lengths
4. Run optimization
5. Verify results show improved waste percentage vs Phase 18 placeholder
6. Verify console shows no errors
</verification>

<success_criteria>
1. FFD algorithm correctly sorts cuts descending before placement
2. Stock pieces sorted descending (longest tried first)
3. Kerf correctly applied: (N-1) gaps for N cuts
4. Summary includes linear feet used vs available
5. TypeScript compilation passes
6. Optimization results are equal to or better than Phase 18 placeholder
</success_criteria>

<output>
After completion, create `.planning/phases/19-linear-optimizer/19-01-SUMMARY.md`
</output>
