---
phase: 21-bom-integration-shop-checklist
plan: 03
type: execute
wave: 2
depends_on: ["21-02"]
files_modified:
  - src/lib/components/cutlist/ManualPlacement.svelte
  - src/routes/cutlist/[id]/+page.svelte
  - src/lib/server/schema.ts
  - src/routes/api/cutlist/[id]/cuts/[cutId]/+server.ts
autonomous: true

must_haves:
  truths:
    - "User can drag stock items and drop onto cuts to assign stock"
    - "User can manually edit cut position within assigned stock"
    - "Manual assignments persist to database"
    - "Conflicts (overlapping cuts) are flagged with visual warning"
  artifacts:
    - path: "src/lib/components/cutlist/ManualPlacement.svelte"
      provides: "Drag-drop stock assignment and position editing"
      min_lines: 150
    - path: "src/lib/server/schema.ts"
      provides: "assignedStockId and overridePosition columns on cutListCuts"
      contains: "assignedStockId.*text"
    - path: "src/routes/api/cutlist/[id]/cuts/[cutId]/+server.ts"
      provides: "PATCH endpoint extended for stock assignment and position"
      exports: ["PATCH"]
  key_links:
    - from: "src/lib/components/cutlist/ManualPlacement.svelte"
      to: "native HTML5 drag-drop"
      via: "ondragstart/ondragover/ondrop event handlers"
      pattern: "ondrop.*handleDrop"
    - from: "src/lib/components/cutlist/ManualPlacement.svelte"
      to: "/api/cutlist/[id]/cuts/[cutId]"
      via: "fetch PATCH for assignment"
      pattern: "fetch.*PATCH.*assignedStockId"
---

<objective>
Implement manual override features allowing drag-drop stock assignment and position editing for fine-tuned control over cut placement.

Purpose: Enable users to manually adjust algorithm results when they have specific preferences for which stock to use or where cuts should be positioned.

Output: ManualPlacement component with drag-drop zones for stock-to-cut assignment and inline position editing with conflict detection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-bom-integration-shop-checklist/21-RESEARCH.md

# Required prior work
@.planning/phases/21-bom-integration-shop-checklist/21-02-SUMMARY.md

# Patterns to follow
@src/lib/components/bom/BOMItem.svelte
@src/lib/server/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Schema for Manual Assignment</name>
  <files>src/lib/server/schema.ts</files>
  <action>
Add columns to cutListCuts for manual stock assignment and position override.

**Schema changes:**
Add after completedAt column in cutListCuts:
```typescript
// Manual override fields
assignedStockId: text('assigned_stock_id').references(() => cutListStock.id, { onDelete: 'set null' }),
overridePosition: real('override_position')  // nullable, null = use algorithm position
```

**Important:**
- assignedStockId references cutListStock.id with SET NULL on delete (if stock deleted, assignment clears)
- overridePosition is nullable real (inches from start of stock)
- null overridePosition means use algorithm-calculated position

After schema change, run: `npm run db:push` to apply migration.
  </action>
  <verify>`npm run db:push` succeeds without errors</verify>
  <done>cutListCuts table has assignedStockId and overridePosition columns</done>
</task>

<task type="auto">
  <name>Task 2: Extend API Endpoint for Manual Assignment</name>
  <files>src/routes/api/cutlist/[id]/cuts/[cutId]/+server.ts</files>
  <action>
Extend the existing PATCH endpoint to handle stock assignment and position override.

**Extended request body:**
```typescript
interface PatchBody {
  completed?: boolean;
  assignedStockId?: string | null;  // null to clear assignment
  overridePosition?: number | null;  // null to clear override
}
```

**Implementation updates:**
1. Parse body to extract optional fields
2. Build update object conditionally:
   ```typescript
   const updates: Record<string, unknown> = {};

   if (typeof body.completed === 'boolean') {
     updates.completed = body.completed;
     updates.completedAt = body.completed ? new Date() : null;
   }

   if ('assignedStockId' in body) {
     // Validate stock exists and belongs to same cutList if not null
     if (body.assignedStockId !== null) {
       const stock = await db.query.cutListStock.findFirst({
         where: and(
           eq(cutListStock.id, body.assignedStockId),
           eq(cutListStock.cutListId, params.id)
         )
       });
       if (!stock) {
         return json({ error: 'Stock not found' }, { status: 404 });
       }
     }
     updates.assignedStockId = body.assignedStockId;
   }

   if ('overridePosition' in body) {
     // Validate position is non-negative if provided
     if (body.overridePosition !== null && body.overridePosition < 0) {
       return json({ error: 'Position must be non-negative' }, { status: 400 });
     }
     updates.overridePosition = body.overridePosition;
   }
   ```
3. Only update if updates object has keys
4. Return { success: true, updates } for confirmation

**Validation:**
- assignedStockId must reference stock in same cutList
- overridePosition must be >= 0 or null
- No need to validate position fits in stock (UI handles conflict display)
  </action>
  <verify>Test with curl: `curl -X PATCH ... -d '{"assignedStockId": "stock-uuid", "overridePosition": 2.5}'`</verify>
  <done>PATCH endpoint handles completed, assignedStockId, and overridePosition updates</done>
</task>

<task type="auto">
  <name>Task 3: Create ManualPlacement Component</name>
  <files>src/lib/components/cutlist/ManualPlacement.svelte</files>
  <action>
Create component for drag-drop stock assignment and position editing.

**Props interface:**
```typescript
interface Cut {
  id: string;
  length: number;
  width: number | null;
  label: string | null;
  assignedStockId: string | null;
  overridePosition: number | null;
}

interface Stock {
  id: string;
  length: number;
  width: number | null;
  label: string | null;
}

interface Props {
  cuts: Cut[];
  stock: Stock[];
  cutListId: string;
  mode: 'linear' | 'sheet';
}
```

**Implementation:**

1. Import dndzone from 'svelte-dnd-action'

2. State management:
   ```typescript
   let localCuts = $state<Cut[]>(initialCuts);
   let editingCutId = $state<string | null>(null);
   let positionInput = $state('');
   ```

3. Stock assignment via drag-drop:
   - Render stock items as draggable cards
   - Each cut has a drop zone for stock assignment
   - On drop, update localCuts and call API to persist

4. Position editing (follow BOMItem inline edit pattern):
   - Click position value to enter edit mode
   - Input field with onblur/Enter to commit
   - Escape to cancel
   - Validate: position >= 0 AND position + cut.length <= stock.length

5. Conflict detection:
   ```typescript
   function detectConflicts(cuts: Cut[], stock: Stock[]): Map<string, string[]> {
     // Group cuts by assignedStockId
     // For each stock, check if cuts overlap:
     // cut1.position + cut1.length > cut2.position (sorted by position)
     // Return map of cutId -> conflicting cutIds
   }
   ```
   - Display warning icon on conflicting cuts
   - Tooltip: "Overlaps with [other cut label]"

6. Reset button:
   - "Reset to Algorithm" clears assignedStockId and overridePosition
   - Calls API with { assignedStockId: null, overridePosition: null }

**Drag-drop implementation:**
```svelte
<div class="stock-list">
  {#each stock as stockItem (stockItem.id)}
    <div
      class="stock-card draggable"
      draggable="true"
      ondragstart={(e) => e.dataTransfer.setData('stockId', stockItem.id)}
    >
      {stockItem.label || `Stock ${stockItem.length}"`}
    </div>
  {/each}
</div>

<div class="cuts-list">
  {#each localCuts as cut (cut.id)}
    <div
      class="cut-drop-zone"
      ondragover={(e) => e.preventDefault()}
      ondrop={(e) => handleDrop(e, cut.id)}
    >
      <!-- Cut display with position editing -->
    </div>
  {/each}
</div>
```

**Note:** Use native HTML5 drag-drop for simpler implementation. svelte-dnd-action is available if needed for more complex interactions, but native drag-drop is sufficient for this use case.

**Styling:**
- Stock cards: border with grab cursor
- Drop zones: dashed border, highlight on dragover
- Conflict warning: red border, warning icon
- Assigned stock: solid amber border
  </action>
  <verify>Component renders, drag-drop works, position editing works, conflicts display</verify>
  <done>ManualPlacement enables drag-drop stock assignment and position editing with conflict detection</done>
</task>

<task type="auto">
  <name>Task 4: Integrate ManualPlacement into View Page</name>
  <files>src/routes/cutlist/[id]/+page.svelte, src/routes/cutlist/[id]/+page.server.ts</files>
  <action>
Add ManualPlacement component to the cut list view page.

**Server changes (+page.server.ts):**
1. Extend query to include stock in addition to cuts:
   ```typescript
   db.query.cutLists.findFirst({
     where: and(
       eq(cutLists.id, params.id),
       eq(cutLists.userId, user.id)
     ),
     with: {
       cuts: { orderBy: cutListCuts.position },
       stock: { orderBy: cutListStock.position }
     }
   })
   ```

**Page changes (+page.svelte):**
1. Import ManualPlacement component
2. Add tabs or sections: "Checklist" | "Manual Placement"
3. Default to Checklist view
4. Manual Placement tab shows ManualPlacement component with cuts and stock
5. Both views share the same cut list data

**Tab implementation:**
```svelte
let activeTab = $state<'checklist' | 'manual'>('checklist');

<div class="tabs">
  <button class:active={activeTab === 'checklist'} onclick={() => activeTab = 'checklist'}>
    Checklist
  </button>
  <button class:active={activeTab === 'manual'} onclick={() => activeTab = 'manual'}>
    Manual Placement
  </button>
</div>

{#if activeTab === 'checklist'}
  <ShopChecklist cuts={cutList.cuts} cutListId={cutList.id} mode={cutList.mode} />
{:else}
  <ManualPlacement cuts={cutList.cuts} stock={cutList.stock} cutListId={cutList.id} mode={cutList.mode} />
{/if}
```

**Tab styling:**
- Use existing button styles
- Active tab: amber background
- Inactive tab: ghost style
  </action>
  <verify>
1. Navigate to /cutlist/{id}
2. See tabs: Checklist | Manual Placement
3. Switch between tabs
4. Manual Placement shows drag-drop interface
5. Make assignment, refresh - assignment persists
  </verify>
  <done>View page has tabbed interface with Checklist and Manual Placement views</done>
</task>

</tasks>

<verification>
1. Navigate to saved cut list at /cutlist/{id}
2. Switch to Manual Placement tab
3. Drag a stock item onto a cut - assignment displays
4. Refresh page - assignment persists
5. Edit cut position via click-to-edit
6. Enter invalid position (negative or beyond stock) - validation prevents
7. Create overlapping cuts - see conflict warning
8. Click "Reset to Algorithm" - assignments clear
9. Switch to Checklist tab - marking complete still works
</verification>

<success_criteria>
- CUT-31: User can drag-drop materials to assign stock (drag-drop interface)
- CUT-32: User can manually override cut placement (position editing with validation)
- Manual assignments persist across page refreshes
- Conflict detection warns about overlapping cuts
</success_criteria>

<output>
After completion, create `.planning/phases/21-bom-integration-shop-checklist/21-03-SUMMARY.md`
</output>
