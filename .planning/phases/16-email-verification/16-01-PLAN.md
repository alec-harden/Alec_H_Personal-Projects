---
phase: 16-email-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/server/schema.ts
  - src/lib/server/auth.ts
  - src/lib/server/email.ts
autonomous: true

must_haves:
  truths:
    - "Email verification tokens can be generated and stored"
    - "Tokens are hashed with SHA-256 before storage"
    - "Verification email can be sent via Resend"
    - "Users table has emailVerified boolean column"
  artifacts:
    - path: "src/lib/server/schema.ts"
      provides: "emailVerificationTokens table and users.emailVerified column"
      contains: "emailVerificationTokens"
    - path: "src/lib/server/auth.ts"
      provides: "Token generation and validation functions"
      exports: ["generateEmailVerificationToken", "verifyEmailToken", "markEmailAsVerified"]
    - path: "src/lib/server/email.ts"
      provides: "Verification email sending"
      exports: ["sendVerificationEmail"]
  key_links:
    - from: "src/lib/server/auth.ts"
      to: "src/lib/server/schema.ts"
      via: "imports emailVerificationTokens table"
      pattern: "import.*emailVerificationTokens"
---

<objective>
Add email verification token infrastructure and schema changes.

Purpose: Establish the database schema and utility functions for email verification tokens, following the proven Phase 15 password reset pattern with 24-hour expiration.

Output: Database schema with emailVerificationTokens table and emailVerified user column, plus auth functions for token generation/validation and email sending function.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-email-verification/16-RESEARCH.md

# Existing files to extend
@src/lib/server/schema.ts
@src/lib/server/auth.ts
@src/lib/server/email.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add schema changes for email verification</name>
  <files>src/lib/server/schema.ts</files>
  <action>
Add to schema.ts:

1. Add columns to users table:
   - `emailVerified: integer('email_verified', { mode: 'boolean' }).notNull().default(false)`
   - `emailVerifiedAt: integer('email_verified_at', { mode: 'timestamp' })`

2. Create emailVerificationTokens table (parallel to passwordResetTokens):
   ```typescript
   export const emailVerificationTokens = sqliteTable('email_verification_tokens', {
     tokenHash: text('token_hash').primaryKey(), // SHA-256 hash of token
     userId: text('user_id')
       .notNull()
       .references(() => users.id, { onDelete: 'cascade' }),
     expiresAt: integer('expires_at', { mode: 'timestamp' }).notNull(),
     createdAt: integer('created_at', { mode: 'timestamp' }).notNull()
   });
   ```

3. Add relations for emailVerificationTokens (same pattern as passwordResetTokens):
   - Add `emailVerificationTokens: many(emailVerificationTokens)` to usersRelations
   - Create emailVerificationTokensRelations with user relation

4. Run `npm run db:push` to apply schema changes.

Note: The users table definition needs to be updated with the new columns. Place them after the existing columns (disabled, createdAt).
  </action>
  <verify>
Run `npm run db:push` - should complete without errors.
Run `npm run check` - TypeScript should pass.
  </verify>
  <done>
Schema includes emailVerificationTokens table and users has emailVerified + emailVerifiedAt columns. Database migrated successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add token generation and validation functions</name>
  <files>src/lib/server/auth.ts</files>
  <action>
Add to auth.ts (following the existing password reset token pattern):

1. Import emailVerificationTokens from schema (add to existing import)

2. Add generateEmailVerificationToken function:
   ```typescript
   /**
    * Generate an email verification token for a user.
    * Deletes any existing tokens for this user first.
    * Returns the plaintext token (only shown once, in email).
    */
   export async function generateEmailVerificationToken(userId: string): Promise<string> {
     // Delete any existing tokens for this user
     await db.delete(emailVerificationTokens).where(eq(emailVerificationTokens.userId, userId));

     // Generate 32 random bytes (64 hex characters)
     const tokenBytes = crypto.randomBytes(32);
     const token = tokenBytes.toString('hex');

     // Hash token with SHA-256 before storage
     const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

     // Token expires in 24 hours (longer than password reset)
     const expiresAt = new Date();
     expiresAt.setHours(expiresAt.getHours() + 24);

     // Store hashed token
     await db.insert(emailVerificationTokens).values({
       tokenHash,
       userId,
       expiresAt,
       createdAt: new Date()
     });

     // Return plaintext token (for email)
     return token;
   }
   ```

3. Add verifyEmailToken function:
   ```typescript
   /**
    * Validate an email verification token.
    * Returns userId if valid, null if invalid or expired.
    * Does NOT consume the token - call markEmailAsVerified after validation.
    */
   export async function verifyEmailToken(token: string): Promise<string | null> {
     // Hash the submitted token
     const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

     // Find token in database
     const verificationToken = await db.query.emailVerificationTokens.findFirst({
       where: eq(emailVerificationTokens.tokenHash, tokenHash)
     });

     if (!verificationToken) {
       return null; // Token not found
     }

     // Check expiry
     if (verificationToken.expiresAt < new Date()) {
       // Delete expired token
       await db.delete(emailVerificationTokens).where(eq(emailVerificationTokens.tokenHash, tokenHash));
       return null;
     }

     return verificationToken.userId;
   }
   ```

4. Add markEmailAsVerified function:
   ```typescript
   /**
    * Mark user's email as verified and consume the token.
    * @param userId - The user ID to mark as verified
    * @param token - The plaintext token to consume
    */
   export async function markEmailAsVerified(userId: string, token: string): Promise<void> {
     const tokenHash = crypto.createHash('sha256').update(token).digest('hex');

     // Mark email as verified
     await db.update(users)
       .set({
         emailVerified: true,
         emailVerifiedAt: new Date()
       })
       .where(eq(users.id, userId));

     // Delete token (single use)
     await db.delete(emailVerificationTokens).where(eq(emailVerificationTokens.tokenHash, tokenHash));
   }
   ```

Import `users` in the update query if not already imported for this purpose.
  </action>
  <verify>
Run `npm run check` - TypeScript should pass with no errors.
Verify functions are exported by checking the file.
  </verify>
  <done>
auth.ts exports generateEmailVerificationToken, verifyEmailToken, and markEmailAsVerified functions. All follow the Phase 15 password reset pattern with 24-hour expiration.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add verification email sending function</name>
  <files>src/lib/server/email.ts</files>
  <action>
Add to email.ts (following the existing sendPasswordResetEmail pattern):

Add sendVerificationEmail function:
```typescript
/**
 * Send email verification email with verification link
 * @param email - User's email address
 * @param token - Plaintext verification token (will be included in URL)
 */
export async function sendVerificationEmail(email: string, token: string): Promise<void> {
  const resend = getResendClient();
  const verifyUrl = `${getBaseUrl()}/auth/verify-email?token=${token}`;

  // Use Resend test domain for development, real domain for production
  const fromAddress = env.RESEND_FROM_EMAIL || 'WoodShop Toolbox <onboarding@resend.dev>';

  const { error } = await resend.emails.send({
    from: fromAddress,
    to: email,
    subject: 'Verify your email - WoodShop Toolbox',
    html: `
      <!DOCTYPE html>
      <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
        </head>
        <body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; background-color: #fafaf9;">
          <div style="background-color: white; padding: 32px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
            <h1 style="color: #292524; margin: 0 0 16px 0; font-size: 24px;">Verify your email</h1>
            <p style="color: #57534e; line-height: 1.6; margin: 0 0 24px 0;">
              Thanks for signing up for WoodShop Toolbox!
              Click the button below to verify your email address. This link expires in 24 hours.
            </p>
            <p style="margin: 0 0 24px 0;">
              <a href="${verifyUrl}"
                 style="display: inline-block; background-color: #b45309; color: white; padding: 12px 24px;
                        text-decoration: none; border-radius: 6px; font-weight: 500;">
                Verify Email
              </a>
            </p>
            <p style="color: #78716c; font-size: 14px; line-height: 1.5; margin: 0 0 16px 0;">
              Or copy and paste this link into your browser:
            </p>
            <p style="word-break: break-all; color: #b45309; font-size: 14px; margin: 0 0 24px 0;">
              ${verifyUrl}
            </p>
            <hr style="border: none; border-top: 1px solid #e7e5e4; margin: 24px 0;">
            <p style="color: #a8a29e; font-size: 13px; margin: 0;">
              If you didn't create an account with WoodShop Toolbox, you can safely ignore this email.
            </p>
          </div>
        </body>
      </html>
    `
  });

  if (error) {
    console.error('Failed to send verification email:', error);
    throw new Error(`Failed to send verification email: ${error.message}`);
  }
}
```

The email template follows the same amber (#b45309) branding as the password reset email. Key differences from password reset:
- Subject: "Verify your email" not "Reset your password"
- Message: Welcome message, 24-hour expiry (not 1-hour)
- Footer: "If you didn't create an account" (not "didn't request password reset")
  </action>
  <verify>
Run `npm run check` - TypeScript should pass.
Verify sendVerificationEmail is exported.
  </verify>
  <done>
email.ts exports sendVerificationEmail function with amber-branded HTML template matching password reset email style.
  </done>
</task>

</tasks>

<verification>
1. `npm run db:push` completes successfully
2. `npm run check` passes with no TypeScript errors
3. Schema includes:
   - emailVerificationTokens table with tokenHash, userId, expiresAt, createdAt
   - users.emailVerified boolean column
   - users.emailVerifiedAt timestamp column
4. auth.ts exports: generateEmailVerificationToken, verifyEmailToken, markEmailAsVerified
5. email.ts exports: sendVerificationEmail
</verification>

<success_criteria>
- [ ] emailVerificationTokens table created in schema
- [ ] users table has emailVerified and emailVerifiedAt columns
- [ ] Token functions follow Phase 15 password reset pattern (SHA-256, single active token)
- [ ] Verification email template uses amber branding, 24-hour expiry messaging
- [ ] All TypeScript compiles without errors
- [ ] Database migration applied successfully
</success_criteria>

<output>
After completion, create `.planning/phases/16-email-verification/16-01-SUMMARY.md`
</output>
